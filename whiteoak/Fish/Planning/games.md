To: CS4500 Staff

From: Mirai Sahara, Andrew Duffy

Subject: Milestone #3 Game Design

Date: 10/15/2020

###Quick overview of GameState

A GameState needs to track a Board, a list of Players, a turn order, as well as some stats that the playerâ€™s shouldnt have access to (score and game-over status for example). Each Board maintains its own data representations for tiles, fish, and dimensions. Every Player in the list of Players maintains its unique identifier, color, age and list of avatars (penguins in this case).

###Representing an entire game:

An entire game is a tree where the nodes are GameStates. The children of a node represent the game states that can be reached through the potential moves for a player in the parent game state, based on whose turn it is. If the avatars for a player in a game state have 10 possible moves in total, then there will be 10 children for the node. In case of storage concerns there may be a need to limit the tree at a certain depth. 

A GameNode class could be used as a wrapper around this. A GameMode object contains a GameState along with its children GameNodes.
The children game nodes are found in a dictionary mapping moves to the nodes. In every GameState there is a 
list of possible movements, and each one will map to a new GameNode (the node you'd reach by executing that movement).

###Example pseudocode
Class GameNode:

	Current_State = GameState
	
	Children = {movement1: node1, movement2: node2, ... movementN: nodeN}

Some limited look-ahead could be useful for an AI planning its next move. A simple game AI would play out various scenarios from its multiple options to figure out the most ideal action. Usually this means pruning the tree at a certain depth to avoid having to go through a massive number of nodes. Even if it is possible to generate the entire tree, it would be wise to enforce a pruning so that AIs cannot make the 100% best possible move. 

###External Interface:

There should be some way to access the tree at a given depth (ex: what are the possible game states 5 turns in). 

There should be a way to see the next possible game states from a given node in the tree; ex: a player can see what movements their opponent might take this turn, then see their own options from each outcome.

A referee should be able to confirm the validity of a gamestate by finding it within the tree.

If we are unable to generate the entire tree, then it should be possible to generate a path through the tree to a requested game state.
Since we won't have the entire tree, if a specific game state is requested then it will need to be generated by 
going down the tree. If it is possible to generate the entire tree, then generating this "path" will be very easy. 